<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional+edit//EN" "xhtml1-transitional+edit.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xmlns:edit="http://xmlns.grorg.org/SVGT12NG/">
<head>
  <title>Rendering Model</title>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/>
  <link rel="stylesheet"           title="Default"               type="text/css" media="screen" href="style/default_svg.css"/>
  <link rel="alternate stylesheet" title="No issues/annotations" type="text/css" media="screen" href="style/default_no_issues.css"/>
  <link rel="alternate stylesheet" title="CSS3 Unmodified"       type="text/css" media="screen" href="style/default.css"/>
  <link rel="alternate stylesheet" title="SVG 1.1"               type="text/css" media="screen" href="style/svg-style.css"/>
  <!-- W3C style sheet will be added here during processing. -->
</head>
<body>

<h1>Rendering Model</h1>

<div class="annotation">
  <p>
    SVG 2 Requirement: Support the z-index.
  </p>
  <p>
    Resolution: We will add Jonathan Watt's z-index proposal to SVG 2.
  </p>
  <p>
    <a href="http://www.w3.org/2011/03/03-svg-minutes.html#item03">Auckland 2011 F2F day 5</a>.
  </p>
  <p>
    Purpose: Allow reordering (such as when a planet orbits the sun). Reordering without script support (e.g. CSS :hover).
  </p>
  <p>
    Owner: Jonathan (Action 3002).
  </p>
</div>

<div class="annotation">
  <p>
    The SVG 2 rendering model will follow the rules defined by the <a href="http://www.w3.org/TR/compositing/">Compositing and Blending specification</a>.
  </p>
  <p>
    Resolution: <a href="http://www.w3.org/2012/07/24-svg-minutes.html#item09">Seattle/Paris 2012 F2F day 3</a>.
  </p>
  <p>
    Owner: Nikos (Action 3332).
  </p>
</div>

<h2 id="Introduction">Introduction</h2>

<p>Implementations of SVG are expected to behave as though they
implement a rendering (or imaging) model corresponding to the
one described in this chapter. <span class="ready-for-wider-review">
Real implementations may choose to implement the model in the way
that they see fit, but the result on any device supported by the
implementation must, in most cases, match this model.</span></p>

<p>The appendix on <a href="conform.html">conformance
requirements</a> describes the extent to which an actual
implementation may deviate from this description. In practice
an actual implementation <span class="ready-for-wider-review">may</span>
deviate slightly because of
limitations of the output device (e.g. only a limited range of
colors might be supported) and because of practical limitations
in implementing a precise mathematical model (e.g. for
realistic performance curves are approximated by straight
lines, the approximation need only be sufficiently precise to
match the conformance requirements).</p>

<h2 id="PaintersModel">The painters model</h2>

<div class="ready-for-wider-review">

<p>SVG uses a "painters model" of rendering. <a>Paint</a>
is applied in successive operations to the output device such
that each operation paints onto some area of the output device,
possibly obscuring paint that has previously been layed down.

After each object or group is painted, it becomes part of the background
for the next painting operation.

SVG 2 supports advanced blending modes and compositing operations that
control how each painting operation interacts with the background.
The rules governing these painting operations are outlined in the
<a href="http://www.w3.org/TR/compositing/">Compositing and Blending Specification</a>.
</p>
</div>

<h2 id="RenderingOrder">Rendering order</h2>
<p>
<span class="ready-for-wider-review">
Elements in SVG are positioned in three dimensions. In addition to their
position on the x and y axis of the <a>viewport</a>, SVG elements are also
positioned on the z-axis. The position on the z-axis defines the order that 
they are painted.
<br/><br/>
Along the z-axis, elements are grouped into 'stacking contexts', each stacking
context has an associated stack level.
A stack level may contain one or more child nodes - either child
stack levels, <a>graphics elements</a>, or <a>'g'</a> elements.
<a>Graphics elements</a> and <a>'g'</a> elements within single
stack level are painted in document order - that is, they are painted
in the order that they are defined in the document.
<br/><br/>
Each stack level is assigned an integer value that defines it's
position on the z-axis relative to other stack levels within the same
stacking context. Lower values are painted first, and so
elements in a stack level with a higher value will paint over one 
with a lower value.
<br/><br/>
By default, everything is placed in stack level zero.
</span>
</p>

<h3 id="ZIndexProperty">Controlling element rendering order: the <span class='property'>'z-index'</span> property</h3>

<p class="note">See the CSS 2.1 specification for the definition
of <a>'z-index'</a>. [<a href="refs.html#ref-CSS21">CSS21</a>]</p>

<p>The <a>'z-index'</a> property allows an element to be assigned to a 
stack level.
</p>

<p class="ready-for-wider-review">
The rules governing behaviour for SVG elements with the <a>'z-index'</a>
property specified are outlined below:
</p>

<p class="note">CSS <a href="http://www.w3.org/TR/CSS2/visuren.html#propdef-z-index">specifies</a> a
property named <a>'z-index'</a>.  The <a href="http://www.w3.org/TR/CSS2/zindex.html">CSS rules
that define the effect of the <span class='property'>'z-index'</span> property</a>
were written specifically for the CSS box model, and those rules do not make
sense as they stand for most SVG elements (most SVG elements do not participate
in or establish a CSS box model layout).  This section specifies how
implementations must handle the <a>'z-index'</a> property on elements in the SVG
namespace.</p>

<p>Contrary to the rules in CSS 2.1, the <a>'z-index'</a> property applies to all SVG
elements regardless of the value of the <a>'position'</a> property, with one exception:
as for boxes in CSS 2.1, outer <a>'svg'</a> elements must be positioned for <a>'z-index'</a>
to apply to them.</p>

<p>The <a>'z-index'</a> property specifies:</p>

<ol>
  <li>The stack level of the element in the current stacking context.</li>
  <li>Whether the element establishes a new local stacking context.</li>
</ol>

<p>Values have the following meanings:</p>

<dl>
  <dt>&lt;integer&gt;</dt>
  <dd>This integer is the stack level of the element in the current
  stacking context. The element also establishes a new local
  stacking context for its descendants.</dd>

  <dt>auto</dt>
  <dd>The stack level of the element in the current stacking context
  is the same as its parent element, unless its parent established
  a new stacking context, in which case its stack level is 0. The
  element does not establish a new local stacking context.</dd>
</dl>

<div class="example">
  <p>Here is a simple example:</p>
  <pre>&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;rect x="0"  width="100" height="100" fill="red"    z-index="-1"/&gt;
  &lt;rect x="40" width="100" height="100" fill="lime"/&gt;
  &lt;rect x="80" width="100" height="100" fill="blue"   z-index="1"/&gt;
  &lt;rect x="60" width="100" height="100" fill="aqua"/&gt;
  &lt;rect x="20" width="100" height="100" fill="yellow" z-index="-1"/&gt;
&lt;/svg&gt;</pre>
  <p>In this example there are three stack levels: -1, 0 (the default) and 1. The red
  and yellow rects are in stack level -1, the lime and aqua rects are in stack
  level 0 (the default), and the blue rect is in stack level 1. Going from lowest
  stack level to highest, and painting the elements in each stack level in
  document order, the painting order is: red, yellow, lime, aqua, blue.</p>
</div>

<p>A new stacking context must be established at an SVG element for its descendants if:</p>

<ul>
  <li>it is the root element</li>

  <li>the <a>'z-index'</a> property applies to the element and its computed
   value is an integer</li>

  <li>the element is an <a>outermost svg element</a>, or a <a>'foreignObject'</a>,
  <a>'image'</a>, <a>'marker element'</a>, <a>'mask element'</a>, <a>'pattern'</a>,
  <a>'symbol'</a> or <a>'use'</a> element</li>

  <li>the element is an inner <a>'svg'</a> element and the computed value of its
  <a>'overflow'</a> property is a value other than <span class='prop-value'>visible</span></li>

  <li>the element is subject to explicit clipping:
    <ul>
      <li>the <a>'clip'</a> property applies to the element and it has a
      computed value other than <span class='prop-value'>auto</span></li>

      <li>the <a>'clip-path'</a> property applies to the element and it has a
      computed value other than <span class='prop-value'>none</span></li>
    </ul>
  </li>

  <li>the <a>'opacity'</a> property applies to the element and it has a
  computed value other than <span class='prop-value'>1</span></li>

  <li>the <a>'mask property'</a> property applies to the element and it has a computed
  value other than <span class='prop-value'>none</span></li>

  <li>the <a>'filter property'</a> property applies to the element and it has a
  computed value other than <span class='prop-value'>none</span></li>

  <li class="ready-for-wider-review">a property defined in another specification is
  applied and that property is defined to establish a stacking context in SVG</li>
</ul>

<!--
<p>For a user friendly explanation of the terms "stack level" and "stacking
context", see the z-index primer document. For the normative rules regarding how
stacking contexts and stack levels affect SVG elements, see below.</p>
-->

<p>Stacking contexts and stack levels are conceptual tools used to describe the
order in which elements must be painted one on top of the other when the
document is rendered, and for determining which element is highest when
determining the target of a pointer event. Stacking contexts and stack levels do
not affect the position of elements in the DOM tree, and their presence or
absence does not affect an element's position, size or orientation in the
canvas' X-Y plane - only the order in which it is painted.</p>

<p>Stacking contexts can contain further stacking contexts. A stacking context is
atomic from the point of view of its parent stacking context; elements in
ancestor stacking contexts may not come between any of its elements.</p>

<p>Each element belongs to one stacking context. Each element in a given stacking
context has an integer stack level. Elements with a higher stack level must be
placed in front of elements with lower stack levels in the same stacking
context. Elements may have negative stack levels. Elements with the same stack
level in a stacking context must be stacked according to document order.</p>

<p>With the exception of the <a>'foreignObject'</a> element, the back to front
stacking order for a stacking context created by an SVG element is:</p>

<ol>
  <li>the background and borders of the element forming the stacking
  context, if any</li>

  <li>child stacking contexts created by descendants with negative stack
  levels, primarily ordered by most negative first, then by tree order</li>

  <li>descendants with <span class='prop-value'>'z-index: auto'</span> or
  <span class='prop-value'>'z-index: 0'</span>, in tree order</li>

  <li>child stacking contexts created by descendants with positive stack levels,
  primarily ordered by lowest index first, then by tree order</li>
</ol>

<p>Since the <a>'foreignObject'</a> element creates a "fixed position containing block" in
CSS terms, the normative rules for the stacking order of the stacking context
created by <a>'foreignObject'</a> elements are the rules in Appendix E of CSS 2.1.</p>

<div class="example">
  <p>In the following example, the <a>'z-index'</a> property on the <a>'g'</a>
  element is set to zero. This creates a new stacking context to contain the
  <a>'g'</a> element's children without moving the <a>'g'</a> to a different
  level in the document's root stacking context:</p>
  <pre>&lt;svg xmlns="http://www.w3.org/2000/svg"&gt;
  &lt;g z-index="0"&gt;
    &lt;!-- this is a self contained graphic --&gt;
    &lt;rect x="40" width="100" height="100" fill="lime" z-index="1"/&gt;
    &lt;rect x="20" width="100" height="100" fill="yellow"/&gt;
  &lt;/g&gt;
  &lt;rect x="60" width="100" height="100" fill="aqua"/&gt;
  &lt;rect x="0" width="100" height="100" fill="red" z-index="-1"/&gt;
&lt;/svg&gt;</pre>

  <p>The example's root stacking context contains two stack levels: -1 and 0. The red
  <a>'rect'</a> is in level -1, and the <a>'g'</a> element and aqua <a>'rect'</a> are in level 0. Inside
  stack level 0, the <a>'g'</a> element's <a>'z-index'</a> property creates a new nested stacking
  context at the <a>'g'</a> for the <a>'g'</a> element's children. In this child stacking
  context there are two stack levels: 0 and 1. The yellow <a>'rect'</a> is in level 0 (the
  default), and the lime <a>'rect'</a> is in level 1.</p>

  <p>Painting of this example starts with the stack levels of the root stacking
  context. First the red rect is painted in level -1, then in level 0 the <a>'g'</a>
  element is painted followed by the aqua rect. When the <a>'g'</a> element is painted,
  the child stacking context that its z-index created and all of that context's
  stack levels are also painted. In this child stacking context, first the yellow
  rect in level 0 is painted, followed by the lime rect in level 1. It's only
  after the <a>'g'</a> and the stacking context that it creates has been painted that the
  aqua rect is painted. Note that this means that although the z-index of 1 for
  the lime rect is a higher value than the (implicit) z-index of 0 for the aqua
  rect, the containment provided by the <a>'g'</a>'s child stacking context results in the
  aqua rect painting over the lime rect. The painting order is therefore: red,
  yellow, lime, aqua.</p>
</div>

<h2 id="Elements">How elements are rendered</h2>
<div class="ready-for-wg-review">
<p>
Individual <a>graphics elements</a> are treated as if they are non <a>isolated</a>
groups, the components (fill, stroke, etc) that make up a graphic element
(See  <a href="#PaintingShapesAndText">Painting shapes and text</a>) being
members of that group. See <a href="#Grouping">How groups are rendered</a>.
</p>
</div>

<h2 id="Grouping">How groups are rendered</h2>
<div class="ready-for-wider-review">
</div>
<div class="ready-for-wg-review">
<p>
Grouping elements, such as the <a>'g'</a> element (see <a>container elements</a>
) create a <a>compositing group</a>. The Compositing and Blending specification
[<a href="refs.html#ref-COMPOSITINGBLENDING">COMPOSITING-BLENDING</a>]
normatively describes how to render <a>compositing groups</a>.
In SVG, effects may be applied to a group. For example, opacity, Filter Effects
or masking. These effects are applied to the rendered result of the group
immediately before the group is blended and composited with the
<a>group backdrop</a>. Applying any such effects to a group makes that 
group isolated.
<br/><br/>
Thus, rendering a <a>compositing group</a> follows the following steps:
If the group is isolated:
</p>
<ol>
<li>The <a>initial backdrop</a> is set to a new buffer initialised with
rgba(0,0,0,0)</li>
<li>The contents of the group are rendered
<a href="#RenderingOrder">in order</a> into the <a>initial backdrop</a></li>
<li>Filter Effects and other effects that modify the group canvas are applied</li>
<li>The group canvas is blended and composited with the <a>group backdrop</a></li>
</ol>
else (the group is not isolated):
<ol>
<li>The <a>initial backdrop</a> is set to the <a>group backdrop</a></li>
<li>The contents of the group are rendered,
<a href="#RenderingOrder">in order</a>, onto the <a>initial backdrop</a></li>
</ol>
</div>

<h3 id="ObjectAndGroupOpacityProperties">Object and group opacity: the
effect of the <span class="property">'opacity'</span> property</h3>

<p class="note">See the CSS Color Module Level 3 for the definition
of <a>'opacity'</a>. [<a href="refs.html#ref-CSS3COLOR">CSS3COLOR</a>]</p>

<p>The <a>'opacity'</a> property specifies how opaque a given
graphical element or container element will be when it is
painted to the canvas.  When applied to a container element,
this is known as <em>group opacity</em>, and when applied to
an individual rendering element, it is known as <em>object
opacity</em>.  The principle for these two operations however
is the same.</p>

<p>There are several other opacity-related properties in SVG:</p>

<ul>
<li><a>'fill-opacity'</a>, which specifies the opacity of a fill
operation;</li>

<li><a>'stroke-opacity'</a>, which specifies the opacity of a stroking
operation;</li>

<li><a>'solid-opacity'</a>, which specifies the opacity of a solid color
paint server; and</li>

<li><a>'stop-opacity'</a>, which specifies the opacity of a gradient stop.</li>
</ul>

<p>These four opacity properties are involved in intermediate rendering operations.
Object and group opacity however can be thought of as a post-processing operation.
Conceptually, the object or group to which <a>'opacity'</a> applies
is rendered into an RGBA offscreen image.  The offscreen image as whole is then blended
into the canvas with the specified <a>'opacity'</a> value used uniformly
across the offscreen image.
<span class="ready-for-wg-review">
Thus, the presence of <a>'opacity property'</a> causes the group to be
<a>isolated</a>.
</span>
</p>

<p>The <a>'opacity'</a> property applies to the following SVG elements:
<a>'svg'</a>, <a>'g'</a>, <a>'symbol'</a>, <a>'marker element'</a>,
<a>'a'</a>, <a>'switch'</a>, <a>graphics elements</a> and
<a>text content child elements</a>.</p>

<div class="example">
<p>The following example illustrates various usage of the <a>'opacity'</a>
property on objects and groups.</p>

<edit:includefile href='images/masking/opacity01.svg'/>

<div class='figure'>
<img class='bordered' src='images/masking/opacity01.svg' alt='Image showing different groups of circles blended into the background.'/>
<p class='caption'>Each group of red and green circles is first rendered
to an offscreen image before being blended with the background
blue rectangle as a whole, with the given <a>'opacity'</a> values.</p>
</div>

<p>In the example, the top row of circles have differing opacities,
ranging from 1.0 to 0.2. The bottom row illustrates five <a>'g'</a> elements,
each of which contains overlapping red and green circles, as follows:</p>

<ul>
<li>The first group shows the opaque case for reference. The group has
opacity of 1, as do the circles.</li>

<li>The second group shows group opacity when the elements in the group are
opaque.</li>

<li>The third and fourth group show that opacity is not commutative. In the
third group (which has opacity of 1), a semi-transparent green circle is
drawn on top of a semi-transparent red circle, whereas in the fourth group a
semi-transparent red circle is drawn on top of a semi-transparent green
circle. Note that area where the two circles intersect display different
colors. The third group shows more green color in the intersection area,
whereas the fourth group shows more red color.</li>

<li>The fifth group shows the multiplicative effect of opacity settings.
Both the circles and the group itself have opacity settings of .5. The
result is that the portion of the red circle which does not overlap with the
green circle (i.e., the top/right of the red circle) will blend into the
blue rectangle with accumulative opacity of .25 (i.e., .5*.5), which, after
blending into the blue rectangle, results in a blended color which is 25%
red and 75% blue.</li>
</ul>
</div>

<h2 id="TypesOfGraphicsElements">Types of graphics elements</h2>

<p>SVG supports three fundamental types of <a>graphics elements</a>
that can be rendered onto the canvas:</p>

<ul>
<li><a>Shapes</a>, which represent some combination of straight line
and curves</li>
<li>Text, which represents some combination of character glyphs</li>
<li>Raster images, which represent an array of values that
specify the paint color and opacity (often termed alpha) at a
series of points on a rectangular grid. (SVG requires support
for specified raster image formats under
<a href="conform.html">conformance requirements</a>.)</li>
</ul>

<h3 id="PaintingShapesAndText">Painting shapes and text</h3>

<p>Shapes and text can be <a>filled</a> (i.e., apply paint to the
interior of the shape) and <a>stroked</a> (i.e., apply paint
along the outline of the shape).</p>

<p>For certain types of shapes, <a href="painting.html#Markers">marker
symbols</a> (which themselves can consist of any combination of shapes,
text and images) can be drawn at positions along the
shape boundary. Each marker symbol
is painted as if its graphical content were expanded into the
SVG document tree just after the shape object which is using
the given marker symbol. The graphical contents of a marker
symbol are rendered using the same methods as graphics
elements. Marker symbols are not applicable to text.</p>

<p>The order in which fill, stroke and markers are painted is determined
by the <a>'paint-order'</a> property. The default is that 
fill is painted first, then the stroke, and then the
marker symbols. The marker symbols are rendered in order along
the outline of the shape, from the start of the shape to the
end of the shape.</p>

<p>Each fill and stroke operation has its own opacity settings;
thus, you can fill and/or stroke a shape with a
semi-transparently drawn solid color, with different opacity
values for the fill and stroke operations.</p>

<p>The fill and stroke operations are entirely independent
painting operations; thus, any stroke applied to the shape will be painted on
top of part of the fill.</p>

<p>SVG supports numerous built-in types of paint which can
be used in fill and stroke operations. These are described in
<a href="pservers.html">Paint Servers</a>.</p>

<h3 id="PaintingRasterImages">Painting raster images</h3>

<p>When a raster image is rendered, the original samples are
"resampled" using standard algorithms to produce samples at the
positions required on the output device. Resampling
requirements are discussed under
<a href="conform.html">conformance requirements</a>.</p>

<p class="issue" data-issue="5">Should we mention anything regarding animated images?</p>

<h2 id="FilteringPaintRegions">Filtering painted regions</h2>
<p>SVG allows any painting operation to be filtered. (See
<a href="http://www.w3.org/TR/filter-effects/">Filter Effects</a>.)</p>

<p>In this case the result must be as though the paint
operations had been applied to an intermediate canvas
initialized to transparent black, of a size determined by the
rules given in <a href="http://www.w3.org/TR/filter-effects/">Filter Effects</a> then
filtered by the processes defined in
<a href="http://www.w3.org/TR/filter-effects/">Filter Effects</a>.</p>

<div class="ready-for-wider-review">
<h2 id="ClippingAndMasking">Clipping and Masking</h2>

<p>SVG supports the following clipping/masking features:</p>

<ul>
<li>clipping paths, which either uses
any combination of <a>'path'</a>, <a>'text'</a> and
<a>basic shapes</a> or basic shapes to serve as
the outline of a (in the absence of anti-aliasing) 1-bit
mask, where everything on the "inside" of the outline is
allowed to show through but everything on the outside is
masked out</li>

<li>masks, which are
<a>container elements</a>
which can contain <a>graphics elements</a>
or other container elements which define a set of graphics
that is to be used as a semi-transparent mask for compositing
foreground objects into the current background.</li>
</ul>

<p>Both, clipping and masking, are specified in the module CSS Masking
[<a href="refs.html#ref-CSS-MASKING">CSS-MASKING</a>].</p>
</div>

<h2 id="ParentCompositing">Parent Compositing</h2>

<p>SVG document fragments can be semi-opaque. In many
environments (e.g., Web browsers), the SVG document fragment
has a final compositing step where the document as a whole is
blended translucently into the background canvas.</p>
<p class="todo">This is defined as the Page Group in Compositing and Blending - there was some
discussion about what the page group should composite with - find that and check
text</p>


<h2 id="OverflowAndClipProperties">The <span class="property">'overflow'</span>
property</h2>

<p class="issue">This property definition table need to be replaced
with a link to <a href="http://www.w3.org/TR/css3-box/">CSS3-box</a>.
<br/>Dirk: Probably not. It is a WD, not updated for 5 years.</p>

<table class="propdef">
<tr>
<th>Name:</th>
<td><dfn id="OverflowProperty">overflow</dfn></td>
</tr>
<tr>
<th>Value:</th>
<td>visible | hidden | scroll | auto</td>
</tr>
<tr>
<th>Initial:</th>
<td>visible</td>
</tr>
<tr>
<th>Applies to:</th>
<td><a href="coords.html#ElementsThatEstablishViewports">elements
which establish a new viewport</a>, <a>'pattern'</a> elements
and <a>'marker element'</a> elements</td>
</tr>
<tr>
<th>Inherited:</th>
<td>no</td>
</tr>
<tr>
<th>Percentages:</th>
<td>N/A</td>
</tr>
<tr>
<th>Media:</th>
<td>visual</td>
</tr>
<tr>
<th>Computed&#160;value:</th>
<td>as specified</td>
</tr>
<tr>
<th><a>Animatable</a>:</th>
<td>yes</td>
</tr>
</table>

<p>The <a>'overflow'</a> property has the same parameter values and has the
same meaning <a href="http://www.w3.org/TR/2011/REC-CSS2-20110607/visufx.html#propdef-overflow">as defined in CSS 2.1</a>
([<a href="refs.html#ref-CSS21">CSS21</a>], section 11.1.1);
however, the following additional points apply:</p>

<ul>
  <li>For those elements to which the <a>'overflow'</a> property can apply, if
  the <a>'overflow'</a> property has the value <span class='prop-value'>hidden</span> or <span class='prop-value'>scroll</span>,
  the effect is that a new clipping path in the shape of a rectangle is created.
  The result is equivalent to defining a <a>'clipPath'</a> element whose
  content is a <a>'rect'</a> element which defines the equivalent rectangle,
  and then specifying the &lt;uri&gt; of this <a>'clipPath'</a> element on the
  <a>'clip-path'</a> property for the given element.
  </li>
  
  <li>
  When <span class='prop-value'>scroll</span> is specified on an
  <a>'svg'</a> element and if the user agent uses a scrolling mechanism that
  is visible on the screen (such as a scroll bar or a panner), that mechanism should
  be displayed for the viewport whether or not any of its content is clipped.
  </li>

  <li>If the <a>'overflow'</a> property has a value other than
  <span class='prop-value'>hidden</span> or <span class='prop-value'>scroll</span>,
  the property has no effect (i.e., a clipping rectangle is not created).
  </li>

  <li>Within SVG content, the value <span class='prop-value'>auto</span> is
  equivalent to the value <span class='prop-value'>visible</span>.
  <p class="issue"><a href="http://www.w3.org/TR/2011/REC-CSS2-20110607/visufx.html#propdef-overflow">CSS implies</a> that 'auto' should be clipped rather
  than visible, do we want to follow that or not?</p>
  </li>

  <li>When an <a>outermost svg element</a> is embedded inline within a
  parent markup language which uses <a href="http://www.w3.org/TR/2011/REC-CSS2-20110607/visuren.html">CSS layout</a>
  ([<a href="refs.html#ref-CSS21">CSS21</a>], chapter 9)
  or <a href="http://www.w3.org/TR/2006/REC-xsl11-20061205/">XSL formatting</a>
  [<a href="refs.html#ref-XSL">XSL</a>], if the
  <a>'overflow'</a> property has the value <span class='prop-value'>hidden</span>
  or <span class='prop-value'>scroll</span>, then the user agent will
  establish an initial clipping path equal to the bounds of the initial
  <a href="coords.html#SVGViewport">viewport</a>; otherwise, the initial
  clipping path is set according to the <a href="http://www.w3.org/TR/2011/REC-CSS2-20110607/visufx.html#overflow">clipping rules as defined in CSS 2.1</a>
  ([<a href="refs.html#ref-CSS21">CSS21</a>], section 11.1.1).</li>

  <li>When an <a>outermost svg element</a> is standalone or embedded
  inline within a parent markup language which does not use CSS layout
  or XSL formatting, the
  <a>'overflow'</a> property on the <a>outermost svg element</a> is ignored
  for the purposes of visual rendering and the initial clipping path is set to
  the bounds of the initial <a href="coords.html#SVGViewport">viewport</a>.
  Note that the value <span class='prop-value'>hidden</span> still means that
  no scrolling user interface should be provided.
  </li>

  <li>The initial value for <a>'overflow'</a> as defined
  in [<a href="http://www.w3.org/TR/2011/REC-CSS2-20110607/visufx.html#overflow">CSS21-overflow</a>]
  is 'visible', and this applies also to the <a>outermost svg element</a>; however,
  for child elements of an SVG document, SVG's <a href="styling.html#UAStyleSheet">user agent style sheet</a>
  overrides this initial value and sets the <a>'overflow'</a> property on the 
   <a>'svg'</a>, <a>'image'</a>, <a>'pattern'</a> and <a>'iframe'</a> elements
   to the value <span class="prop-value">hidden</span>.</li>
</ul>

<p>As a result of the above, the default behavior of SVG user agents is to
establish a clipping path to the bounds of the initial
<a href="coords.html#SVGViewport">viewport</a> and to establish a new clipping
path for each <a href="coords.html#ElementsThatEstablishViewports">element which
establishes a new viewport</a> and each <a>'pattern'</a> and
<a>'marker element'</a> element.</p>

<h3 id="AutoClipAtViewportNotViewBox">Clip to viewport vs. clip to
<span class="attr-name">'viewBox'</span></h3>

<p>It is important to note that initial values for the <a>'overflow'</a> and
<a>'clip'</a> properties and the <a href="styling.html#UAStyleSheet">user agent
style sheet</a> will result in an initial clipping path that is set to the
bounds of the initial viewport. When attributes <a>'viewBox'</a> and
<a>'preserveAspectRatio'</a> attributes are specified, it is sometime
desirable that the clipping path be set to the bounds of the <a>'viewBox'</a>
instead of the viewport (or reference rectangle, in the case of
<a>'marker element'</a> and <a>'pattern'</a> elements), particularly when
<a>'preserveAspectRatio'</a> specifies uniform scaling and the aspect ratio of
the <a>'viewBox'</a> does not match the aspect ratio of the viewport.</p>

<p>To set the initial clipping path to the bounds of the <a>'viewBox'</a>, set
the bounds of <a>'clip'</a> property to the same rectangle as specified on the
<a>'viewBox'</a> attribute. (Note that the parameters do not match.
<a>'clip'</a> takes values &lt;top&gt;, &lt;right&gt;,&lt;bottom&gt; and
&lt;left&gt;, whereas <a>'viewBox'</a> takes values &lt;min-x&gt;,
&lt;min-y&gt;, &lt;width&gt; and &lt;height&gt;.)</p>

<h3 id="InitialClippingPath">The initial clipping path</h3>

<p>When an <a>'svg'</a> element is either the root element in the
document or is embedded within a document whose layout is determined
according to the layout rules of CSS or XSL, then the user agent must
establish an initial clipping path for the SVG document fragment. The
<a>'overflow'</a> property along with additional SVG
user agent processing rules determine the initial clipping path which
the user agent establishes for the SVG document fragment:</p>


</body>
</html>
